@startuml
header as-is current state
caption CQL Workspace/CQL Library Editor - Create New or Edit CQL library item
title CQL Workspace - Open CQL Library

actor User order 10
participant "MAT GWT" as gwt order 20
participant "MAT Server" as srv order 30


User -> gwt: Open for edit selected or create a new measure
note over gwt
    # The UI View will have edit or read-only mode based on user's edit edit permissions
    # CQL free text is enabled when user has edit permissions and
end note
gwt --> User: show Measure Composer / Measure Details

User -> gwt: Navigate to Measure Composer / CQL Workspace
gwt --> User: show CQL Workspace

'------------------------------------------------------
newpage General information
User -> gwt: modify "General Information" fields
User -> gwt: save
gwt -> srv: CQLLibraryService::saveAndModifyCQLGeneralInfo(\n\tString libraryId, \n\tString libraryValue, \n\tString libraryComment)
alt is current CQL Library editable
    note over srv
        isEditable = (isOwner || isSuperUser || isSharedToEdit) && isDraft;
    end note
    srv -> srv: load library record from DB by libraryId

    alt library name not blank and setid not blank\n and library exist in DB with specified name and setId
        srv --> gwt: return result = {success: false, failure: DUPLICATE_LIBRARY_NAME}
    else library name is unique
        srv -> srv: load library xml
        srv -> srv: cqlService::saveAndModifyCQLGeneralInfo
        note right: see below for call details
        group cqlService::saveAndModifyCQLGeneralInfo
            opt library name more 500 characters
                srv -> gwt: return result = {success: false, failure: SERVER_SIDE_VALIDATION}
            end
            srv -> srv: update xml with new library name
            srv -> srv: update xml with new library comment
        end
        srv -> srv: update library name (record)
        srv -> srv: update library xml
        srv -> srv: store to DB
    end
    srv -> gwt: return result {success: true}
else not editable
    srv -> gwt: return not editable
end

'------------------------------------------------------
newpage Includes
opt Includes
    note over gwt, srv
        TBD
    end note
end

'------------------------------------------------------
newpage Value Sets
opt Value Sets
    note over gwt, srv
        TBD
    end note
end

'------------------------------------------------------
newpage Codes
opt Codes
    note over gwt, srv
        TBD
    end note
end

'------------------------------------------------------
newpage Parameters
opt Parameters
    note over gwt, srv
        TBD
    end note
end

'------------------------------------------------------
newpage Definition
User -> gwt: add/modify definition
gwt --> user: done
User -> gwt: save
group addAndModifyDefintions
    opt validation failed
        note over gwt
            #definition name is a valid expression name, not empty, not a keyword, not Patient
            #definition Name has no special chars
            #definition comment < 250 chars
            #definition comment contains no invalid chars
        end note
        gwt -[#red]> User: show error
    end
    gwt -> srv: MeasureService::saveAndModifyDefinitions(\n\tmeasureId, \n\tmodified definition, \n\tcurrent definition, \n\tlist of defnitions,\n\t isFormattable: true)
    opt current measure not editable
        srv --[#red]> gwt: result {success: false}
    end
    srv -> srv: load measure xml by measureId
    group CqlService::saveAndModifyDefinitions (xml, modified definition, current definition, definition list, isFormattable)
        srv -> srv: create cqlModel from xml
        note over srv
            validate the new identifier, unless it was equal to the definition
            # validate no special chars
            # validate identifier name is not duplicated
            # validate comment is not too long
        end note
        srv -> srv: update cql definition in the model
        srv -> srv: insert cql definition and then parse cql for errors
        opt isFormattable
            srv -> srv: format definition
        end
    end
    srv -> srv: update xml with risk adjustment variables
    srv -> srv: update xml, replace cqlLookUp with measure
    srv -> srv: save measure xml to DB
    srv -> gwt: return result {success: true}
end

'------------------------------------------------------
newpage Function
User -> gwt: add/modify function
gwt --> user: done
User -> gwt: save
group addAndModifyFunction
    opt validation failed
                note over gwt
                    #function name is a valid expression name, not empty, not a keyword, not Patient
                    #functionName has no special chars
                    #function comment < 250 chars
                    #function comment contains no invalid chars
                end note
        gwt -[#red]> User: show error
    end
    gwt -> srv: MeasureService::saveAndModifyFunctions(measureId, param, function, functions, isFormattable: true)
    opt current measure not editable
        srv --[#red]> gwt: result {success: false}
    end
    srv -> srv: load measure xml by measureId
    group CqlService::saveAndModifyFunctions (xml, modified function, current function, function list, isFormattable)
        srv -> srv: create cqlModel from xml
        note over srv
            validate the new identifier, unless it was equal to the definition
            # validate no special chars
            # validate identifier name is not duplicated
            # validate function argument list for alias to follow cql alias naming convention
            # validate comment not too long or has no invalid chars
        end note
        srv -> srv: update cql with function definition in the model
        srv -> srv: insert cql with function definition and then parse cql for errors
        opt isFormattable
            srv -> srv: format function
        end
    end
    srv -> srv: update xml with dunction display name
    srv -> srv: update xml, replace cqlLookUp with measure
    srv -> srv: save measure xml to DB
    srv -> gwt: return result {success: true}
end

'------------------------------------------------------
newpage Edit or save CQL Library

note over User,gwt
<b>Precondition:
library is open for editing
end note


opt CQL Libary Editor
    User -> gwt: click Save
    gwt -> gwt: saveCQLFile
    gwt -> srv: saveCQLFile(measureId, cql)
    srv -> srv: load previous measure's XML from DB by measureId
    srv -> srv: load previous measure from DB by measureId
    srv -> srv: previousModel = create CQLModel object from the previous measure's XML
    srv -> srv: create linter confg(\n\tprev. lib name,\n\tformatted(prev rev. number, prev. VERSION),\n\t'QDM',\n\tprev. QDM_VERSION, previousModel)
    srv -> srv: result:SaveUpdateCQLResult = cqlSevice::saveCQLFile (prev. measure's XML, cql, linter config)
    group cqlSevice::saveCQLFile
        opt if measure is not editable return
            srv --> gwt
            note over gwt, srv
                isEditable = (isOwner || isSuperUser || isSharedToEdit) && isDraft;
            end note
        end
        srv -> srv: parsedResult = parse cql
        srv -> srv: reverseEngineeredCQLLookup = marshallCQLModel
        note left srv: re-create cql from the parsed model
        srv -> srv: check for syntax error
        srv -> srv: check parsed model for duplicated identifiers\n or identifier as a keyword
        srv -> srv: check parsed result has errors
        alt parsed result has <b>NO</b> errors
            note over srv
                #format cql
                #re-construct model from formatted cql
                #update parsedResult with xml marshalled from formatted cql model
                #update parsedResult with cql re-constructed from formatted cql model
            end note
        else parsed result has errors
            note over srv
                Update parsedResult with xml
                Update parsedResult with cql
            end note
        end
        srv -> srv: linter = CQLUtil.lint(cql, linter config)
        srv -> srv: validateDatatypeCombinations (\n\tcql model,\n\tvalue set data type map,\n\tcode data type map)
        srv -> srv: create SaveUpdateCQLResult
        note over srv
            SaveUpdateCQLResult is created from parsed xml, cql model and
            all errors, warnings from parsing and linter and data types validation
        end note
        note over srv #FFAAAA
            <b>Remark!</b> cql / xml are parsed and marshaled back and forth multiple times.
            It can be optimized for better performance.
            Also, both ReverseEngineerListener and Linter use similar code and ANTLR parser.
            There is a potential in code re-use and performance optimization.
        end note
    end
    srv -> srv: update xml cqlLookUp with measure
    opt result.isSuccess()
        srv -> srv: clean definitions from population groups
        note over srv
            need to clean definitions from populations and groupings.
            go through all of the definitions in the previous model and check if they are in the new model
            if the old definition is not in the new model, clean the groupings
        end note
        srv -> srv: clean measure observation and groups
        note over srv
            do the same thing for functions
        end note
    end
    srv -> srv: save measure xml
    opt result.isSuccess()
        srv -> srv: add to cql library history
        srv -> srv: save measure
    end
    srv --> gwt: return result of SaveUpdateCQLResult
end

footer actual on 01/22/2020

@enduml